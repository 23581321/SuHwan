#include <stdio.h>

int main(void)
{
        int n, wine, max=0, newWine;
        scanf("%d",&n);
        int amount[10000][3]={0, }; // 마신 포도주의 양을 저장할 2차원 배열이다. 각각의 열은 연속하여 마신 잔의 수를 의미한다.
        scanf("%d",&wine);
        amount[0][1]=wine; // 첫잔은 마신다와 마시지 않는다의 두 경우가 있다. 배열이 0으로 초기화 되었으므로 마시는 경우만 따로 초기화 해준다.
        for(int i=1 ; i<n ; i++){
                scanf("%d",&wine);
                if(amount[i][0] <= amount[i-1][2]){
                        amount[i][0] = amount[i-1][2];
                } // 연속하여 마신 잔이 2개일 경우 선택할 수 있는 경우는 마시지 않는다 밖에 없으므로 마시지 않았을 경우의 최대값보다 크면 새로운 값을 저장한다.
                for(int j=0 ; j<2 ; j++){ // 연속하여 마신 잔의 개수가 0 또는 1일 경우 마시지 않는다와 마신다의 경우가 있으므로 열 0과 1에 대하여 두 경우를 검사한다.
                        if(amount[i][0]<=amount[i-1][j]){
                                amount[i][0] = amount[i-1][j];
                        } // 마시지 않았을 경우의 최대값과 비교하여 값의 저장 여부를 결정한다.
                        newWine=amount[i-1][j]+wine; // 새로 입력받은 포도주의 양을 더한다. 마시는 경우를 택했을 때의 크기를 검사할 때 쓰인다.
                        if(amount[i][j+1] <= newWine){
                                amount[i][j+1]=newWine;
                        } // 마시는 경우를 택했을 때, 연속하여 마신 잔에 따라 값을 비교하여 저장 여부를 결정한다.
                }
        }
        for(int k=0 ; k<3 ; k++){
                if(amount[n-1][k]>=max){
                        max=amount[n-1][k];
                }
        } // 마지막 열에 있는 세 정수 중 가장 큰 값이 이 문제의 답이 된다.
        printf("%d\n",max);
        return 0;
} // 이 문제에서의 부분문제는 잔에 담긴 포도주를 먹을지 말지를 택하는 것이다. 그런데 문제의 규칙에
  // 따라서 바로 전 까지 연속해서 마신 포도주에 따라 경우가 나뉜다. 연속하여 마신 포도주가 
  // 없을 때, 연속하여 마신 포도주가 1잔일 때, 연속해서 마신 포도주가 두 잔일 때의 3가지 경우가 나온다.  
  // 이것만 고려하면 나머지는 RGB거리의 풀이와 같다. RGB거리에서 i 번째 집을 색칠하는 최소 비용이
  // i-1번째 까지의 집을 칠하는 최소비용에 값을 더한것과 같았던 것 처럼 i-1번째 까지 최대로 마신
  // 포도주의 양에 i번째 포도주를 마신 양을 더한것이 최대가 된다. RGB에 빨강, 파랑, 초록이 있던 것
  // 처럼 이 문제에는 연속해서 마신 잔이 0, 1, 2 일때가 있다. 여기부터는 문제의 특성을 고려하며
  // RGB거리의 알고리즘을 그대로 사용하면 된다. 
